// MainBoard Code
#include <Arduino.h>
#include <Wire.h>
const byte START_BYTE = 0xAA;
const byte END_BYTE = 0xBB;
const byte DISPLAY_BASE_ADDR = 0x08; // DisplayBoards 0x08 to 0x12
const byte NUM_DISPLAY_BOARDS = 11;
const byte NUM_CHANNELS = 22; // 11 * 2
const unsigned long POLL_INTERVAL = 500; // ms
const byte CASTLE_UP_PIN = A0; // Button to increase castle
const byte CASTLE_DOWN_PIN = A1; // Button to decrease castle
const int DEBOUNCE_TIME = 50;

byte current_castle = 1; // Start with Castle 1 (1-4)
byte targets[22];
byte actuals[22];
unsigned long last_poll = 0;
unsigned long last_button_time = 0;
bool initial_setup_done = false;
void handleCastleSwitch();
void switchCastle(byte castle);
void pollTargets();
void pollActualsAndUpdate();
void sendToDisplays(byte type, byte* values);
bool getPotsFromCastle(byte castle, byte* pots);
void setTargetToCastle(byte castle, byte motor_index, byte value);
void sendRS485(byte to_id, byte cmd, byte len, byte* data);

void setup() {
  Serial.begin(9600); // Terminal output
  Serial1.begin(9600);  // Hardware serial for communication

  pinMode(CASTLE_UP_PIN, INPUT_PULLUP);
  pinMode(CASTLE_DOWN_PIN, INPUT_PULLUP);

  Wire.begin(); // I2C master for DisplayBoards
  memset(targets, 255, sizeof(targets)); // Initialize targets
  memset(actuals, 255, sizeof(actuals)); // Initialize actuals

  // Wait for boards to initialize
  delay(2000);
  switchCastle(current_castle); // Initial setup
  initial_setup_done = true;
  Serial.println("MainBoard started");
}

void loop() {
  handleCastleSwitch();
  if (initial_setup_done) {
    pollTargets();
  }
  if (millis() - last_poll >= POLL_INTERVAL) {
    last_poll = millis();
    pollActualsAndUpdate();
  }
}

void handleCastleSwitch() {
  unsigned long current_time = millis();
  if (current_time - last_button_time > DEBOUNCE_TIME) {
    if (digitalRead(CASTLE_UP_PIN) == LOW) {
      current_castle = min(4, current_castle + 1);
      switchCastle(current_castle);
      last_button_time = current_time;
      Serial.print("Switched to Castle ");
      Serial.println(current_castle);
    } else if (digitalRead(CASTLE_DOWN_PIN) == LOW) {
      current_castle = max(1, current_castle - 1);
      switchCastle(current_castle);
      last_button_time = current_time;
      Serial.print("Switched to Castle ");
      Serial.println(current_castle);
    }
  }
}

void switchCastle(byte castle) {
  byte pots[22];
  if (getPotsFromCastle(castle, pots)) {
    memcpy(targets, pots, sizeof(pots));
    memcpy(actuals, pots, sizeof(pots));
    sendToDisplays(0, pots); // Targets
    sendToDisplays(1, pots); // Actuals
    Serial.println("Castle switch: Pots updated and sent to displays");
  } else {
    Serial.println("Castle switch: Failed to get pots");
  }
}

void pollTargets() {
  for (byte d = 0; d < NUM_DISPLAY_BOARDS; d++) {
    byte addr = DISPLAY_BASE_ADDR + d;
    Wire.requestFrom(addr, (byte)4);
    if (Wire.available() == 4) {
      byte ch1 = Wire.read();
      byte v1 = Wire.read();
      byte ch2 = Wire.read();
      byte v2 = Wire.read();
      if (ch1 == 1 && ch2 == 2) {
        byte index1 = d * 2;
        byte index2 = d * 2 + 1;
        if (targets[index1] != v1) {
          targets[index1] = v1;
          setTargetToCastle(current_castle, index1, v1);
          Serial.print("Target updated: Display ");
          Serial.print(d);
          Serial.print(", Ch1=");
          Serial.println(v1);
        }
        if (targets[index2] != v2) {
          targets[index2] = v2;
          setTargetToCastle(current_castle, index2, v2);
          Serial.print("Target updated: Display ");
          Serial.print(d);
          Serial.print(", Ch2=");
          Serial.println(v2);
        }
      }
    }
  }
}

void pollActualsAndUpdate() {
  byte pots[22];
  if (getPotsFromCastle(current_castle, pots)) {
    memcpy(actuals, pots, sizeof(pots));
    sendToDisplays(1, pots); // Send actuals
    Serial.println("Actuals polled and sent to displays");
  }
  else {
    Serial.println("reiniciou setup");
    Serial1.end();
    delay(200);
    Serial1.begin(9600);
  }
}

void sendToDisplays(byte type, byte* values) {
  for (byte d = 0; d < NUM_DISPLAY_BOARDS; d++) {
    byte addr = DISPLAY_BASE_ADDR + d;
    byte index1 = d * 2;
    byte index2 = d * 2 + 1;

    Serial.print("Sending to Display 0x");
    Serial.print(addr, HEX);
    Serial.print(", Type=");
    Serial.print(type);
    Serial.print(", Ch1=");
    Serial.print(values[index1]);
    Serial.print(", Ch2=");
    Serial.println(values[index2]);

    Wire.beginTransmission(addr);
    Wire.write(type); // 0 for target, 1 for actual
    Wire.write((byte)1); // Channel 1
    Wire.write(values[index1]);
    Wire.endTransmission();

    Wire.beginTransmission(addr);
    Wire.write(type);
    Wire.write((byte)2); // Channel 2
    Wire.write(values[index2]);
    Wire.endTransmission();
  }
}

bool getPotsFromCastle(byte castle, byte* pots) {
  byte cmd = 1;// indica ao castelo o comando que ele deve rodar
  byte len = 0;
  byte dummy[0];// dado qlqr só pra completar padrão do dado
  sendRS485(castle, cmd, len, dummy);
  delay(200);
  sendRS485(castle, cmd, len, dummy);

  unsigned long start_time = millis();
  while (millis() - start_time < 500) {
    if (Serial1.available() >= 28) {
      byte incoming = Serial1.read();
      if (incoming == START_BYTE) {
        byte id = Serial1.read();
        byte rcmd = Serial1.read();
        byte rlen = Serial1.read();
        if (id == castle && rcmd == 1 && rlen == 22) {
          byte data[22];
          for (byte i = 0; i < 22; i++) {
            data[i] = Serial1.read();
          }
          byte checksum = Serial1.read();
          byte end = Serial1.read();

          byte calc_checksum = id ^ rcmd ^ rlen;
          for (byte i = 0; i < 22; i++) {
            calc_checksum ^= data[i];
          }
          if (end == END_BYTE && checksum == calc_checksum) {
            memcpy(pots, data, 22);
            return true;
          }
        }
      }
    }
  }
  Serial.print("Failed to get pots from Castle ");
  Serial.println(castle);
  return false;
}

void setTargetToCastle(byte castle, byte motor_index, byte value) {
  byte cmd = 2;
  byte len = 2;
  byte data[2] = {motor_index, value};
  sendRS485(castle, cmd, len, data);
  Serial.print("Set target: Castle ");
  Serial.print(castle);
  Serial.print(", Motor ");
  Serial.print(motor_index);
  Serial.print(", Value ");
  Serial.println(value);
}

void sendRS485(byte to_id, byte cmd, byte len, byte* data) {
  Serial1.write(START_BYTE);
  Serial1.write(to_id);
  Serial1.write(cmd);
  Serial1.write(len);
  byte checksum = to_id ^ cmd ^ len;
  for (byte i = 0; i < len; i++) {
    Serial1.write(data[i]);
    checksum ^= data[i];
  }
  Serial1.write(checksum);
  Serial1.write(END_BYTE);
  Serial1.flush();
}
