#include <Arduino.h>
#include <Wire.h>
#include <SoftwareSerial.h>

// I2C Configuration
#define DISPLAY_BASE_ADDR 0x08 // DisplayBoards: 0x08 to 0x12
#define NUM_DISPLAYS 11

// RS-485 Configuration
#define RS485_RX 10 // SoftwareSerial RX pin
#define RS485_TX 11 // SoftwareSerial TX pin
#define RS485_DE 12 // Driver Enable pin for MAX485
#define BAUD_RATE 9600 // Set to 9600 for debugging
#define NUM_SLAVES 4
#define START_BYTE 0xFF
#define END_BYTE 0xFE

// Slave Selection Pins
#define SLAVE_SEL_0 2 // LSB for slave selection
#define SLAVE_SEL_1 3 // MSB for slave selection

// Data Structures
struct MotorCommand {
  byte slave_id;
  byte motor_board_id;
  byte motor_id;
  byte value;
};

struct MotorFeedback {
  byte slave_id;
  byte motor_board_id;
  byte motor_id;
  byte pot_value;
};

// SoftwareSerial for RS-485
SoftwareSerial rs485(RS485_RX, RS485_TX);

// Variables
byte selected_slave = 1; // Current slave (1–4)
MotorFeedback feedback_buffer[NUM_DISPLAYS][2]; // Store feedback: [display][channel]
unsigned long last_poll_time = 0;
const unsigned long poll_interval = 100; // Poll every 100ms

// Prototypes

void poll_display_boards();
byte calculate_checksum(byte* data, byte len);
void update_display_boards();
void poll_display_boards();
void send_motor_command(byte slave_id, byte motor_board_id, byte motor_id, byte value);
void process_rs485_feedback();



void setup() {
  // Initialize Serial
  Serial.begin(9600);
  while (!Serial);

  // Initialize I2C as Master
  Wire.begin();

  // Initialize RS-485
  rs485.begin(BAUD_RATE);
  pinMode(RS485_DE, OUTPUT);
  digitalWrite(RS485_DE, LOW); // Receive mode

  // Initialize Slave Selection Pins
  pinMode(SLAVE_SEL_0, INPUT_PULLUP);
  pinMode(SLAVE_SEL_1, INPUT_PULLUP);

  // Initialize feedback_buffer
  for (byte i = 0; i < NUM_DISPLAYS; i++) {
    feedback_buffer[i][0] = {0, i + 1, 1, 0}; // Channel 1
    feedback_buffer[i][1] = {0, i + 1, 2, 0}; // Channel 2
  }

  Serial.println("MainBoard Started");
}

void loop() {
  byte selected_slave = 1; // Current slave (1–4) !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!REMOVER!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
  unsigned long current_time = millis();

  // Update selected slave based on pins
  selected_slave = (digitalRead(SLAVE_SEL_1) << 1) | digitalRead(SLAVE_SEL_0);
  selected_slave = constrain(selected_slave, 1, NUM_SLAVES);

  // Poll DisplayBoards every poll_interval
  if (current_time - last_poll_time >= poll_interval) {
    poll_display_boards();
    last_poll_time = current_time;
  }

  // Process RS-485 feedback
  process_rs485_feedback();

  // Send feedback to DisplayBoards
  update_display_boards();
}

// Poll all DisplayBoards for button updates
void poll_display_boards() {
  for (byte i = 0; i < NUM_DISPLAYS; i++) {
    byte addr = DISPLAY_BASE_ADDR + i;
    
    // Request data: [1, valueCh1, 2, valueCh2]
    Wire.requestFrom(addr, 4);
    if (Wire.available() >= 4) {
      byte ch1 = Wire.read();
      byte val1 = Wire.read();
      byte ch2 = Wire.read();
      byte val2 = Wire.read();
      
      if (ch1 == 1 && val1 <= 99) {
        // Update feedback_buffer with new DisplayBoard value
        feedback_buffer[i][0].pot_value = val1;
        feedback_buffer[i][0].slave_id = selected_slave;
        send_motor_command(selected_slave, i + 1, 1, val1);
        Serial.print("DisplayBoard Update: Addr=0x");
        Serial.print(addr, HEX);
        Serial.print(", Channel=1, Value=");
        Serial.println(val1);
      }
      if (ch2 == 2 && val2 <= 99) {
        // Update feedback_buffer with new DisplayBoard value
        feedback_buffer[i][1].pot_value = val2;
        feedback_buffer[i][1].slave_id = selected_slave;
        send_motor_command(selected_slave, i + 1, 2, val2);
        Serial.print("DisplayBoard Update: Addr=0x");
        Serial.print(addr, HEX);
        Serial.print(", Channel=2, Value=");
        Serial.println(val2);
      }
    } else {
      while (Wire.available()) Wire.read(); // Clear buffer
      Serial.print("I2C Error: DisplayBoard 0x");
      Serial.println(addr, HEX);
    }
  }
}

// Send motor command via RS-485
void send_motor_command(byte slave_id, byte motor_board_id, byte motor_id, byte value) {
  if(slave_id == 1){
    slave_id = 0x01;
  }
  if(slave_id == 2){
    slave_id = 0x02;
  }
  if(slave_id == 3){
    slave_id = 0x03;
  }
  if(slave_id == 4){
    slave_id = 0x04;
  }
  byte packet[7] = {START_BYTE, slave_id, motor_board_id, motor_id, value, 0, END_BYTE};
  packet[5] = calculate_checksum(packet, 5); // Checksum for bytes 0–4
  
  digitalWrite(RS485_DE, HIGH); // Transmit mode
  rs485.write(packet, 7);
  rs485.flush();
  digitalWrite(RS485_DE, LOW); // Back to receive mode
  
  Serial.print("RS485 Sent: Slave=");
  Serial.print(slave_id);
  Serial.print(", MotorBoard=");
  Serial.print(motor_board_id);
  Serial.print(", Motor=");
  Serial.print(motor_id);
  Serial.print(", Value=");
  Serial.println(value);
}

// Process incoming RS-485 feedback
void process_rs485_feedback() {
  static byte buffer[7];
  static byte index = 0;
  
  while (rs485.available()) {
    byte data = rs485.read();
    if (index == 0 && data != START_BYTE) continue; // Wait for start byte
    
    buffer[index++] = data;
    if (index == 7 && buffer[6] == END_BYTE) {
      if (buffer[5] == calculate_checksum(buffer, 5)) {
        MotorFeedback fb = {buffer[1], buffer[2], buffer[3], buffer[4]};
        if (fb.slave_id == selected_slave && fb.motor_board_id <= NUM_DISPLAYS) {
          feedback_buffer[fb.motor_board_id - 1][fb.motor_id - 1] = fb;
          Serial.print("RS485 Feedback: Slave=");
          Serial.print(fb.slave_id);
          Serial.print(", MotorBoard=");
          Serial.print(fb.motor_board_id);
          Serial.print(", Motor=");
          Serial.print(fb.motor_id);
          Serial.print(", Pot=");
          Serial.println(fb.pot_value);
        }
      } else {
        Serial.println("RS485 Error: Invalid checksum");
      }
      index = 0; // Reset buffer
    } else if (index >= 7) {
      index = 0; // Reset on overflow
    }
  }
}

// Update DisplayBoards with feedback
void update_display_boards() {
  for (byte i = 0; i < NUM_DISPLAYS; i++) {
    byte addr = DISPLAY_BASE_ADDR + i;
    
    // Send Channel 1 feedback
    if (feedback_buffer[i][0].pot_value <= 99 && feedback_buffer[i][0].slave_id == selected_slave) {
      Wire.beginTransmission(addr);
      Wire.write(1); // Channel 1
      Wire.write(feedback_buffer[i][0].pot_value);
      Wire.endTransmission();
      Serial.print("I2C Sent to Display 0x");
      Serial.print(addr, HEX);
      Serial.print(": Channel=1, Value=");
      Serial.println(feedback_buffer[i][0].pot_value);
    }
    
    // Send Channel 2 feedback
    if (feedback_buffer[i][1].pot_value <= 99 && feedback_buffer[i][1].slave_id == selected_slave) {
      Wire.beginTransmission(addr);
      Wire.write(2); // Channel 2
      Wire.write(feedback_buffer[i][1].pot_value);
      Wire.endTransmission();
      Serial.print("I2C Sent to Display 0x");
      Serial.print(addr, HEX);
      Serial.print(": Channel=2, Value=");
      Serial.println(feedback_buffer[i][1].pot_value);
    }
  }
}

// Calculate checksum (sum of bytes modulo 256)
byte calculate_checksum(byte* data, byte len) {
  byte sum = 0;
  for (byte i = 0; i < len; i++) {
    sum += data[i];
  }
  return sum;
}